---
title: 算法基础
desc: 算法通常用于解决特定的计算任务，算法使用数学化的描述，更加侧重于思想，可以看做抽象的程序
category: Algorithm
tags: ['basic' 'Algorithm']
---

## 复杂度

> <u>时间复杂度</u>和<u>空间复杂度</u>是衡量一个算法效率的重要标准

### 基本操作数

- 背景：同一个算法在不同计算机上运行的速度有一定的差异，并且实际运行速度难以在理论上进行计算，因此通常考虑的不是算法的实际运行的时间，而是算法运行所需要的基本操作的数量
- 常规计算机的计算过程中，加减乘除、访问变量（基本数据类型的变量）、变量赋值等都可以看作基本操作
- 对 **基本操作的计数** 或是估测可以作为评判算法用时的指标

### 时间复杂度

#### 定义

- 衡量算法的快慢，需要考虑数据规模的大小
  - **数据规模**：一般指输入数字的个数、输入中给出的图的点数与边数等等
- 算法中，衡量算法效率通常是评估 <u>算法运行用时</u> 随 <u>数据规模增长</u> 的趋势，即 **时间复杂度**

#### 背景

- 数据规模增长趋势
  - 在允许算法执行时间更久时，时间复杂度对可处理数据规模的影响会更加明显，远大于同一数据规模下用时的影响
  - 不同基本操作实际用时是不同的，例如 <u>加减法</u>用时远小于 <u>除法</u>用时。计算时间复杂度而忽略不同基本操作之间的区别以及一次基本操作与十次基本操作之间的区别，可以消除基本操作间用时不同的影响
- 时间复杂度的分类
  - **最坏时间复杂度**，即每个输入规模下用时最长的输入对应的时间复杂度。实际算法竞赛中，需要考虑给定数据范围内的最坏时间复杂度，以满足所有的输入实例
  - **平均（期望）时间复杂度**，即每个输入规模下所有可能输入对应用时的平均值的复杂度（随机输入期望用时的复杂度）

### 渐进符号

#### 定义

- **渐进符号** 是 **函数的阶** 的规范描述。
  - 渐进符号忽略了一个函数中增长较慢的部分以及各项的系数（在时间复杂度相关分析中，系数一般称作 <u>常数</u>），而保留了可以用来表明该函数增长趋势的重要部分
  - 记忆方法：
    - 含等于（非严格）用大写，不含等于（非严格）用小写
    - 相等是 Θ，小于是 Ο，大于是 Ω

#### 大 Θ 符号

- $\Theta$ Θ 符号同时给了我们一个函数的上下界

  - 定义：对于函数 $f(n)$ 和 $g(n)$，$f(n)=\Theta(g(n))$，当且仅当 $\exists c_1,c_2,n_0>0$，使得 $\forall n \ge n_0, 0\le c_1\cdot g(n)\le f(n) \le c_2\cdot g(n)$

  - 也就是说，如果函数 $f(n)=\Theta(g(n))$，那么我们能找到两个正数 $c_1, c_2$ 使得 $f(n)$ 被 $c_1\cdot g(n)$ 和 $c_2\cdot g(n)$ 夹在中间

#### 大 O 符号

- 如果只知道一个函数的渐进上界而不知道其渐进下界，可以使用 $O$ 符号
  - 定义：$f(n)=O(g(n))$，当且仅当 $\exists c,n_0$，使得 $\forall n \ge n_0,0\le f(n)\le c\cdot g(n)$
  - 研究时间复杂度时通常会使用 $O$ 符号，因为我们关注的通常是程序用时的上界，而不关心其用时的下界

#### 大 Ω 符号

- 使用 $\Omega$ 符号来描述一个函数的渐进下界
  - 定义：$f(n)=\Omega(g(n))$，当且仅当 $\exists c,n_0$，使得 $\forall n \ge n_0,0\le c\cdot g(n)\le f(n)$

#### 小 o 符号

> 小 $o$ 符号大量应用于数学分析中，函数在某点处的泰勒展开式拥有皮亚诺余项，使用小 $o$ 符号表示严格小于，从而进行等价无穷小的渐进分析。

- 定义：$f(n)=o(g(n))$，当且仅当对于任意给定的正数 $c$，$\exists n_0$，使得 $\forall n \ge n_0,0\le f(n)< c\cdot g(n)$。

#### 小 ω 符号

- 定义：$f(n)=\omega(g(n))$，当且仅当对于任意给定的正数 $c$，$\exists n_0$，使得 $\forall n \ge n_0,0\le c\cdot g(n)< f(n)$

#### 常见性质

-   $f(n) = \Theta(g(n))\iff f(n)=O(g(n))\land f(n)=\Omega(g(n))$
-   $f_1(n) + f_2(n) = O(\max(f_1(n), f_2(n)))$
-   $f_1(n) \times f_2(n) = O(f_1(n) \times f_2(n))$
-   $\forall a \neq 1, \log_a{n} = O(\log_2 n)$
    -   由换底公式可以得知，任何对数函数无论底数为何，都具有相同的增长率，因此渐进时间复杂度中对数的底数一般省略不写。


### 主定理(Master Theorem)

- 可以使用 **Master Theorem** 来快速求得关于递归算法的复杂度

  - $$
    T(n) = a T\left(\frac{n}{b}\right)+f(n)\qquad \forall n > b
    $$

    那么

    $$
    T(n) = \begin{cases}\Theta(n^{\log_b a}) & f(n) = O(n^{\log_b (a)-\epsilon}),\epsilon > 0 \\ \Theta(f(n)) & f(n) = \Omega(n^{\log_b (a)+\epsilon}),\epsilon\ge 0\\ \Theta(n^{\log_b a}\log^{k+1} n) & f(n)=\Theta(n^{\log_b a}\log^k n),k\ge 0 \end{cases}
    $$

- 

> 注意：第二种情况需要满足 **regularity condition**，即 $a f(n/b) \leq c f(n)$， $\forall c<1,\exists N \text{ 使得 } n>N$

### 均摊复杂度

#### 引入

- **均摊分析(Amortized Analysis)** 是一种 <u>用于分析算法和动态数据结构性能</u> 的技术
  - 其不仅关注单次操作的成本，还通过评估一系列操作的平均成本，为整体性能提供更加准确的评估
  - 均摊分析不涉及概率，且只能确保最坏性能的每次操作耗费的平均时间，并不能确认系统的平均性能
  - 在最坏的情况下，均摊分析通过将高成本操作的开销分摊到低成本操作上，确保整体操作的平均成本保持在合理范围内

- 三种主要分析方法：**聚合分析、记账分析、势能分析**
  - 以动态数组的插入操作为例，分别进行分析。C++ 中的 `vector`，其初始容量为 `m=1`，每次插入新元素时，如果数组已满，则需要将数组的大小加倍，然后将原数组中的元素复制到新数组中，最后插入新元素
- 具体分析方法及分析示例参考 [OI-wiki 均摊复杂度](https://oi-wiki.org/basic/amortized-analysis/#%E5%86%85%E5%AE%B9)

## 枚举

### 简介

- **枚举(Enumerate)** 是基于已有知识来猜测答案的一种问题求解策略
  - 枚举的思想是不断地猜测，从可能的集合中一一尝试，然后再判断题目的条件是否成立

### 要点

- 给出解空间：建立简洁的数学模型
  - 可能得情况是什么？要枚举哪些要素？
- 减少枚举的空间
  - 枚举的范围是什么？是所有的内容都需要枚举吗？
- 选择合适的枚举顺序
  - 根据具体题目判断

## 模拟

### 简介

- **模拟** 是用计算机来模拟题目中要求的操作
  - 模拟题目通常具有代码量大、操作多、思路繁复的特点

### 要点

- 动手写代码之前，在草纸上尽可能写好要实现的流程
- 代码中，尽量把每个部分模块化，写成函数、结构体或类
- 对于一些可能重复用到的概念，可以统一转化，方便处理
- 调试时分块调试。模块化的好处就是可以方便的单独调某一部分
- 写代码的时候一定要思路清晰，不要想到什么写什么，要按照落在纸上的步骤写

## 递归&分治

### 递归

#### 概述

- 定义：**递归(Recursion)** 在数学和计算机科学中是指在函数的定义中使用函数自身的方法，在计算机科学中还额外指一种通过重复将问题分解为同类的子问题而解决问题的方法
- 重要特征：**结束条件** 和 **自我调用**
- 优点
  1. 结构清晰，可读性强
  2. 可以有效分析问题的结构
- 缺点
  1. 效率问题：调用层数过多时，会造成 **栈溢出** 的后果

#### 递归优化

- 搜索优化 和 记忆力优化

### 分治

#### 概述

- 定义：**分治(Divide and Conquer)**，即吧一个复杂的问题分成两个或更多的相同或相似的子问题，知道最后子问题可以简单的直接求解，原问题的解即子问题的解的合并

#### 过程

- 基本流程：<u>分解→解决(触底)→合并(回溯)</u>
  - **分解** 原问题为结构相同的子问题
  - 分解到某个容易求解的 **边界** 之后，进行递归求解
  - 将子问题的解 **合并** 成原问题的解
- 分治特征
  - 问题规模缩小到一定程度可以方便解决
  - 问题可以分解为若干个规模较小的相同问题，即该问题具有最优子结构性质，利用该问题分解出的子问题的解可以合并为该问题的解
  - 该问题所分解出的各个子问题是相互独立的，即子问题之间不包含公共的子问题

> 如果各子问题是不独立的，则分治法要重复地解公共的子问题，也就做了许多不必要的工作。此时虽然也可用分治法，但一般用 <u>动态规划</u> 较好

#### 要点

- 分析过程 <u>明确一个函数的作用并相信它能完成这个任务</u>，不应跳进这个函数中探究更多细节

### 区别

- 递归与枚举的区别：枚举是横向地把问题划分，然后依次求解子问题；而递归是把问题逐级分解，是纵向的拆分
- 递归与分治的区别：递归是一种编程技巧，一种解决问题的思维方式；分治算法很大程度上是基于递归的，解决更具体问题的算法思想

## 贪心

### 简介

- 定义：**贪心算法(greedy algorithm)**，是用计算机来模拟一个「贪心」的人做出决策的过程，每一步行动总是按某种指标选取最优的操作
- 适用范围：贪心算法在有最优子结构的问题中尤为有效
  - 最优子结构：问题能够分解成子问题来解决，子问题的最优解能递推到最终问题的最优解

### 要点

- 证明方法
  - 反证法：如果交换方案中任意两个元素/相邻的两个元素后，答案不会变的更好，那么可以推定
  - 归纳法：先得出边界情况（例如 n=1）的最优解 $F_1$，然后再证明：对于每个 n，$F_(n+1)$ 都可以由 $F_n$ 推导出结果
- 解法
  - 排序解法：常见情况是输入一个包含几个（一般一到两个）权值的数组，通过排序后遍历模拟计算的方法求出最优值
  - 后悔解法：思路是无论当前的选项是否最优都接受，然后进行比较，如果选择之后不是最优了，则反悔，舍弃掉这个选项；否则，正式接受。如此往复

### 区别

- 与动态规划的区别：贪心算法与动态规划的不同在于它对每个子问题的解决方案都做出选择，不能回退。动态规划则会保存以前的运算结果，并根据以前的结果对当前进行选择，有回退功能

## 排序

### 概述

- 定义：**排序算法(Sorting Algorithm)** 是一种将一组特定的数据按某种顺序进行排列的算法

- 性质
  - 稳定性：相等的元素经过排序之后相对顺序是否发生了改变
    - 稳定排序：基数、计数、插入、冒泡、归并
    - 不稳定排序：选择、堆、快速、希尔

| 排序方法     | 平均情况           | 最好情况  | 最坏情况 | 空间         | 稳定性 |
| ------------ | ------------------ | --------- | -------- | ------------ | ------ |
| 冒泡         | O(n^2^)            | O(n)      | O(n^2^)  | O(1)         | 稳定   |
| 简单选择排序 | O(n^2^)            | O(n^2^)   | O(n^2^)  | O(1)         | 不稳定 |
| 直接插入排序 | O(n^2^)            | O(n)      | O(n^2^)  | O(1)         | 稳定   |
| 希尔排序     | O(nlogn) ~ O(n^2^) | O(n^1.3^) | O(n^2^)  | O(1)         | 不稳定 |
| 堆排序       | O(nlogn)           | O(nlogn)  | O(nlogn) | O(1)         | 不稳定 |
| 归并排序     | O(nlogn)           | O(nlogn)  | O(nlogn) | O(n)         | 稳定   |
| 快速排序     | O(nlogn)           | O(nlogn)  | O(n^2^)  | O(logn)~O(n) | 不稳定 |

### 选择排序

- **选择排序(Selection Sort)**，每次找出第 i 小的元素，然后将该元素与数组中第 i 个位置上的元素交换
  - 稳定性：由于 swap 操作的存在，是一种不稳定的排序算法
  - 时间复杂度：最优时间复杂度、平均时间复杂度、最坏时间复杂度均为 $O(n^2)$
- 伪代码

![image-20241006193411386](https://bitiful.bayyys.cn/notes/mac/2024/10/image-20241006193411386-1728214451.png)

- 代码实现

```cpp
void selection_sort(int* a, int n) {
  for (int i = 1; i < n; ++i) {
    int ith = i;
    for (int j = i + 1; j <= n; ++j) {
      if (a[j] < a[ith]) {
        ith = j;
      }
    }
    std::swap(a[i], a[ith]);
  }
}
```

### 冒泡排序

- **冒泡排序(Bubble Sort)**，执行过程中，较小的元素像是气泡般慢慢”浮“到数列的顶端
  - 过程：每次检查相邻的两个元素，如果前面的元素与后面的元素满足给定的排序条件，将元素交换
  - 稳定性：稳定
  - 时间复杂度
    - 最优时间复杂度：$O(n)$
    - 最坏时间复杂度：$O(n^2)$
    - 平均时间复杂度：$O(n^2)$
- 伪代码

![image-20241006193829532](https://bitiful.bayyys.cn/notes/mac/2024/10/image-20241006193829532-1728214709.png)

- 代码实现

```cpp
// 假设数组的大小是 n + 1，冒泡排序从数组下标 1 开始
void bubble_sort(int *a, int n) {
  bool flag = true;
  while (flag) {
    flag = false;
    for (int i = 1; i < n; ++i) {
      if (a[i] > a[i + 1]) {
        flag = true;
        int t = a[i];
        a[i] = a[i + 1];
        a[i + 1] = t;
      }
    }
  }
}
```

### 插入排序

- **插入排序(Insertion Sort)**，将排列的元素划分为 <u>已排序</u> 和 <u>未排序</u> 两部分，每次从 <u>未排序</u> 元素中选择一个插入到 <u>已排序</u> 元素中的正确位置
  - 稳定性：稳定
  - 时间复杂度
    - 最优时间复杂度：$O(n)$
    - 最坏时间复杂度：$O(n^2)$
    - 平均时间复杂度：$O(n^2)$

- 伪代码

![image-20241006194515826](https://bitiful.bayyys.cn/notes/mac/2024/10/image-20241006194515826-1728215115.png)

- 代码实现

```cpp
void insertion_sort(int arr[], int len) {
  for (int i = 1; i < len; ++i) {
    int key = arr[i];
    int j = i - 1;
    while (j >= 0 && arr[j] > key) {
      arr[j + 1] = arr[j];
      j--;
    }
    arr[j + 1] = key;
  }
}
```

- 折半插入排序

  - 通过二分算法优化性能，在排序元素数量较多时优化效果比较明显
  - 时间复杂度：仅对直接插入排序时间复杂度中的常数进行优化，故时间复杂度不变

  - 代码实现

```cpp
void insertion_sort(int arr[], int len) {
  if (len < 2) return;
  for (int i = 1; i != len; ++i) {
    int key = arr[i];
    auto index = upper_bound(arr, arr + i, key) - arr;
    // 使用 memmove 移动元素，比使用 for 循环速度更快，时间复杂度仍为 O(n)
    memmove(arr + index + 1, arr + index, (i - index) * sizeof(int));
    arr[index] = key;
  }
}
```

### 计数排序

- **计数排序(Counting Sort)** 是一种线性时间的排序算法

-  排序过程：计数排序的工作原理是使用一个额外的数组 $C$，其中第  个元素是待排序数组  $A$ 中值等于 $i$ 的元素的个数，然后根据数组 $C$  来将 $A$  中的元素排到正确的位置

  - 三个步骤：
    - 计算每个数出现了几次
    - 求出每个数出现次数的 <u>前缀和</u>
    - 利用出现次数的前缀和，从右至左计算每个数的排名
  - 前缀和作用：维持排序算法的稳定性

  - 稳定性：稳定
  - 时间复杂度：$O(n+w)$

- 伪代码

![image-20241006200810290](https://bitiful.bayyys.cn/notes/mac/2024/10/image-20241006200810290-1728216490.png)

- 代码实现

```cpp
const int N = 100010;
const int W = 100010;

int n, w, a[N], cnt[W], b[N];

void counting_sort() {
  memset(cnt, 0, sizeof(cnt));
  for (int i = 1; i <= n; ++i) ++cnt[a[i]];
  for (int i = 1; i <= w; ++i) cnt[i] += cnt[i - 1];
  for (int i = n; i >= 1; --i) b[cnt[a[i]]--] = a[i];
}
```

### 基数排序

- **基数排序(Radix Sort)** 将排序的元素拆分为 k 个关键字，逐一对各个关键字排序后完成对所有元素的排序

  - 稳定性：若内层关键字排序是稳定的，则基数排序稳定
  - 时间复杂度：$O(kn+\Sigma_1^k w_i)$

- 分类

  - 考虑第 1 关键字到第 k 关键字：MSD(Most Significant Digitfirst) 基数排序

  - 考虑第 k 关键字到第 1 关键字：LSD(Least Significant Digitfirst) 基数排序

- 伪代码

![image-20241006204049537](https://bitiful.bayyys.cn/notes/mac/2024/10/image-20241006204049537-1728218449.png)

- 代码实现

```cpp
const int N = 100010;
const int W = 100010;
const int K = 100;

int n, w[K], k, cnt[W];

struct Element {
  int key[K];

  bool operator<(const Element& y) const {
    // 两个元素的比较流程
    for (int i = 1; i <= k; ++i) {
      if (key[i] == y.key[i]) continue;
      return key[i] < y.key[i];
    }
    return false;
  }
} a[N], b[N];

void counting_sort(int p) {
  memset(cnt, 0, sizeof(cnt));
  for (int i = 1; i <= n; ++i) ++cnt[a[i].key[p]];
  for (int i = 1; i <= w[p]; ++i) cnt[i] += cnt[i - 1];
  // 为保证排序的稳定性，此处循环i应从n到1
  // 即当两元素关键字的值相同时，原先排在后面的元素在排序后仍应排在后面
  for (int i = n; i >= 1; --i) b[cnt[a[i].key[p]]--] = a[i];
  memcpy(a, b, sizeof(a));
}

void radix_sort() {
  for (int i = k; i >= 1; --i) {
    // 借助计数排序完成对关键字的排序
    counting_sort(i);
  }
}
```

