---
title: 算法基础
desc: 算法通常用于解决特定的计算任务，算法使用数学化的描述，更加侧重于思想，可以看做抽象的程序
category: Algorithm
tags: ['basic' 'Algorithm']
---

## 复杂度

> <u>时间复杂度</u>和<u>空间复杂度</u>是衡量一个算法效率的重要标准

### 基本操作数

- 背景：同一个算法在不同计算机上运行的速度有一定的差异，并且实际运行速度难以在理论上进行计算，因此通常考虑的不是算法的实际运行的时间，而是算法运行所需要的基本操作的数量
- 常规计算机的计算过程中，加减乘除、访问变量（基本数据类型的变量）、变量赋值等都可以看作基本操作
- 对 **基本操作的计数** 或是估测可以作为评判算法用时的指标

### 时间复杂度

#### 定义

- 衡量算法的快慢，需要考虑数据规模的大小
  - **数据规模**：一般指输入数字的个数、输入中给出的图的点数与边数等等
- 算法中，衡量算法效率通常是评估 <u>算法运行用时</u> 随 <u>数据规模增长</u> 的趋势，即 **时间复杂度**

#### 背景

- 数据规模增长趋势
  - 在允许算法执行时间更久时，时间复杂度对可处理数据规模的影响会更加明显，远大于同一数据规模下用时的影响
  - 不同基本操作实际用时是不同的，例如 <u>加减法</u>用时远小于 <u>除法</u>用时。计算时间复杂度而忽略不同基本操作之间的区别以及一次基本操作与十次基本操作之间的区别，可以消除基本操作间用时不同的影响
- 时间复杂度的分类
  - **最坏时间复杂度**，即每个输入规模下用时最长的输入对应的时间复杂度。实际算法竞赛中，需要考虑给定数据范围内的最坏时间复杂度，以满足所有的输入实例
  - **平均（期望）时间复杂度**，即每个输入规模下所有可能输入对应用时的平均值的复杂度（随机输入期望用时的复杂度）

### 渐进符号

#### 定义

- **渐进符号** 是 **函数的阶** 的规范描述。
  - 渐进符号忽略了一个函数中增长较慢的部分以及各项的系数（在时间复杂度相关分析中，系数一般称作 <u>常数</u>），而保留了可以用来表明该函数增长趋势的重要部分
  - 记忆方法：
    - 含等于（非严格）用大写，不含等于（非严格）用小写
    - 相等是 Θ，小于是 Ο，大于是 Ω

#### 大 Θ 符号

- $\Theta$ Θ 符号同时给了我们一个函数的上下界

  - 定义：对于函数 $f(n)$ 和 $g(n)$，$f(n)=\Theta(g(n))$，当且仅当 $\exists c_1,c_2,n_0>0$，使得 $\forall n \ge n_0, 0\le c_1\cdot g(n)\le f(n) \le c_2\cdot g(n)$

  - 也就是说，如果函数 $f(n)=\Theta(g(n))$，那么我们能找到两个正数 $c_1, c_2$ 使得 $f(n)$ 被 $c_1\cdot g(n)$ 和 $c_2\cdot g(n)$ 夹在中间

#### 大 O 符号

- 如果只知道一个函数的渐进上界而不知道其渐进下界，可以使用 $O$ 符号
  - 定义：$f(n)=O(g(n))$，当且仅当 $\exists c,n_0$，使得 $\forall n \ge n_0,0\le f(n)\le c\cdot g(n)$
  - 研究时间复杂度时通常会使用 $O$ 符号，因为我们关注的通常是程序用时的上界，而不关心其用时的下界

#### 大 Ω 符号

- 使用 $\Omega$ 符号来描述一个函数的渐进下界
  - 定义：$f(n)=\Omega(g(n))$，当且仅当 $\exists c,n_0$，使得 $\forall n \ge n_0,0\le c\cdot g(n)\le f(n)$

#### 小 o 符号

> 小 $o$ 符号大量应用于数学分析中，函数在某点处的泰勒展开式拥有皮亚诺余项，使用小 $o$ 符号表示严格小于，从而进行等价无穷小的渐进分析。

- 定义：$f(n)=o(g(n))$，当且仅当对于任意给定的正数 $c$，$\exists n_0$，使得 $\forall n \ge n_0,0\le f(n)< c\cdot g(n)$。

#### 小 ω 符号

- 定义：$f(n)=\omega(g(n))$，当且仅当对于任意给定的正数 $c$，$\exists n_0$，使得 $\forall n \ge n_0,0\le c\cdot g(n)< f(n)$

#### 常见性质

-   $f(n) = \Theta(g(n))\iff f(n)=O(g(n))\land f(n)=\Omega(g(n))$
-   $f_1(n) + f_2(n) = O(\max(f_1(n), f_2(n)))$
-   $f_1(n) \times f_2(n) = O(f_1(n) \times f_2(n))$
-   $\forall a \neq 1, \log_a{n} = O(\log_2 n)$
    -   由换底公式可以得知，任何对数函数无论底数为何，都具有相同的增长率，因此渐进时间复杂度中对数的底数一般省略不写。


### 主定理(Master Theorem)

- 可以使用 **Master Theorem** 来快速求得关于递归算法的复杂度

  - $$
    T(n) = a T\left(\frac{n}{b}\right)+f(n)\qquad \forall n > b
    $$

    那么

    $$
    T(n) = \begin{cases}\Theta(n^{\log_b a}) & f(n) = O(n^{\log_b (a)-\epsilon}),\epsilon > 0 \\ \Theta(f(n)) & f(n) = \Omega(n^{\log_b (a)+\epsilon}),\epsilon\ge 0\\ \Theta(n^{\log_b a}\log^{k+1} n) & f(n)=\Theta(n^{\log_b a}\log^k n),k\ge 0 \end{cases}
    $$

- 

> 注意：第二种情况需要满足 **regularity condition**，即 $a f(n/b) \leq c f(n)$， $\forall c<1,\exists N \text{ 使得 } n>N$

### 均摊复杂度

#### 引入

- **均摊分析(Amortized Analysis)** 是一种 <u>用于分析算法和动态数据结构性能</u> 的技术
  - 其不仅关注单次操作的成本，还通过评估一系列操作的平均成本，为整体性能提供更加准确的评估
  - 均摊分析不涉及概率，且只能确保最坏性能的每次操作耗费的平均时间，并不能确认系统的平均性能
  - 在最坏的情况下，均摊分析通过将高成本操作的开销分摊到低成本操作上，确保整体操作的平均成本保持在合理范围内

- 三种主要分析方法：**聚合分析、记账分析、势能分析**
  - 以动态数组的插入操作为例，分别进行分析。C++ 中的 `vector`，其初始容量为 `m=1`，每次插入新元素时，如果数组已满，则需要将数组的大小加倍，然后将原数组中的元素复制到新数组中，最后插入新元素

#### 聚合分析

- **聚合分析(Aggregate Analysis)** 通过计算一系列操作的总成本，并将其平均到每次操作上，从而得出每次操作的均摊时间复杂度

> - 关键成本
>   - 数组未满，插入操作的成本为 $O(1)$
>   - 数组已满，插入操作需要扩容，扩容后复制元素的成本为 $O(m)$，其中 m 为当前数组的大小
> - 计算成本
>   - **插入操作的成本**：每次插入新元素的直接成本是常数时间 $O(1)$，对于 n 次操作，总成本为 $O(n)$
>   - **数组扩容的成本**：每次扩容涉及到原数组元素到新数组，操作发生在数组大小为 1,2,4,…,2^k^ 时刻，其中 2^k-1^ 时小于等于 n 的最大幂。扩容操作的成本分别是 1,2,4,…,2^k-1^，总和为 1+2+4+…+2^k-1^=2^k^-1，结果为 $O(n)$
> - 结果分析：总成本为 $O(n)$，均摊到每次操作的成本为 $O(1)$，即使在最坏情况下，平均每次插入操作的成本依然是常数

#### 记账分析

- 记账法(Accounting Method)

#### 均势分析